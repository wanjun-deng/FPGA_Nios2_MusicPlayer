#include "system.h"
#include "altera_avalon_pio_regs.h"
#include "altera_avalon_timer_regs.h"
#include "alt_types.h"
#include <stdio.h>

/* 
 * Scorereader logic migrated from Verilog to C
 * 
 * Keyboard mapping (from scorereader.v):
 * 5'b10000 (0x10): Play
 * 5'b10001 (0x11): Pause
 * 5'b10010 (0x12): Stop
 * 5'b10100 (0x14): Song 0
 * 5'b10101 (0x15): Song 1
 * 5'b10110 (0x16): Song 2
 * 5'b10111 (0x17): Song 3
 */

int main() {
    alt_u8 playing = 0;
    alt_u8 songchoose = 0; // 对应键值4 (Song 0)
    alt_u8 addr_cnt = 0;
    alt_u8 restart = 0;
    alt_u32 beat_timer = 0;
    // 变量声明（符合 C89 标准）
    alt_u8 keyboard;
    alt_u8 last_keyboard = 0; // 初始化为0，与硬件Key_Board复位值一致，防止自动播放
    alt_u8 current_addr;
    alt_u8 inote;
    volatile int d;


    // Verilog beater was 24-bit counter at 50MHz.
    // Overflow period = 2^24 / 50,000,000 = 0.33554432 seconds.
    // Timer 0 is set to 1ms (50,000 cycles).
    // So we need approx 336 timer ticks for one beat.
    const alt_u32 BEAT_THRESHOLD = 336;

    printf("Nios II Scorereader Logic Started (LED shows Keyboard)\n");

    // Initialize Timer 0 for 1ms period
    // 50MHz / 1000 = 50,000 cycles
    IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_0_BASE, 50000 & 0xFFFF);
    IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_0_BASE, (50000 >> 16) & 0xFFFF);
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE,
        ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
        ALTERA_AVALON_TIMER_CONTROL_START_MSK);

    while (1) {
        // 1. Read Keyboard Input
        keyboard = IORD_ALTERA_AVALON_PIO_DATA(PIO_KEYBOARD_BASE);

        // 2. Handle Control Logic (scorereader.v always block)

        // Check for auto-stop conditions first (highest priority in Verilog if-else)
        // We need to read the current note from ROM to check bit 7
        current_addr = (songchoose << 5) | (addr_cnt & 0x1F);
        IOWR_ALTERA_AVALON_PIO_DATA(PIO_ADDR_BASE, current_addr);

        // Small delay to let ROM output stabilize (PIO is slow)
        for(d=0; d<10; d++);
        inote = IORD_ALTERA_AVALON_PIO_DATA(PIO_INOTE_BASE);

        if (((inote & 0x80) == 0) || (addr_cnt == 0x1F)) {
            playing = 0;
            restart = 1;
        } else {
            // 原先带有 keyboard & 0x10 判断的逻辑（已注释）
            if (keyboard & 0x10) { 
                switch (keyboard & 0x1F) {
                    case 0x10: playing = 1; restart = 0; break;
                    case 0x11: playing = 0; break;
                    case 0x12: playing = 0; restart = 1; break;
                    case 0x14: playing = 0; restart = 1; songchoose = 0; break;
                    case 0x15: playing = 0; restart = 1; songchoose = 1; break;
                    case 0x16: playing = 0; restart = 1; songchoose = 2; break;
                    case 0x17: playing = 0; restart = 1; songchoose = 3; break;
                }
            }
            

            // 仅在按键值发生变化时处理逻辑，实现单次触发（防止循环播放）
            /*
            if (keyboard != last_keyboard) {
                switch (keyboard & 0x0F) {
                    case 0x00: // Play
                        playing = 1;
                        restart = 0;
                        break;
                    case 0x01: // Pause
                        playing = 0;
                        break;
                    case 0x02: // Stop
                        playing = 0;
                        restart = 1;
                        break;
                    case 0x04: // Song 0
                        playing = 0;
                        restart = 1;
                        songchoose = 0;
                        break;
                    case 0x05: // Song 1
                        playing = 0;
                        restart = 1;
                        songchoose = 1;
                        break;
                    case 0x06: // Song 2
                        playing = 0;
                        restart = 1;
                        songchoose = 2;
                        break;
                    case 0x07: // Song 3
                        playing = 0;
                        restart = 1;
                        songchoose = 3;
                        break;
                }
                last_keyboard = keyboard;
            }
        }
        */
        // 3. Output Logic
        if (playing) {
            IOWR_ALTERA_AVALON_PIO_DATA(PIO_ONOTE_BASE, inote);
        } else {
            IOWR_ALTERA_AVALON_PIO_DATA(PIO_ONOTE_BASE, 0);
        }
        IOWR_ALTERA_AVALON_PIO_DATA(PIO_PLAYING_BASE, playing);
        
        // 显示键值后4位到 LED，且低电平点亮
        IOWR_ALTERA_AVALON_PIO_DATA(PIO_LED_BASE, ~(keyboard & 0x0F));

        // 4. Timing Logic (beater + beatct)
        if (restart) {
            addr_cnt = 0;
            beat_timer = 0;
        }

        // Poll Timer for 1ms ticks
        if (IORD_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE) & ALTERA_AVALON_TIMER_STATUS_TO_MSK) {
            IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0); // Clear timeout flag

            // 涔愯氨鑺傛媿鎺у埗
            if (playing) {
                beat_timer++;
                if (beat_timer >= BEAT_THRESHOLD) {
                    beat_timer = 0;
                    addr_cnt++;
                }
            }

        }
    }

    return 0;
}
